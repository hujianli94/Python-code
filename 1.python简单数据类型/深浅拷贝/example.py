#!/usr/bin/env python
# -*- coding:utf8 -*-
'''
浅拷贝：
    在内存开辟新的地址空间，
    对于可变对象，拷贝时，拷贝顶层引用，可变对象改变时，顶层引用不变。
    对于不可变对象，拷贝时，拷贝地址引用一份，对象改变，浅拷贝对象也变，共享可变对象引用。

深拷贝：拷贝所有对象，顶级对象及其嵌套对象。或者说：父级对象及其子对象，
        对于不可变对象，依旧指向引用内存空间。
        对于可变对象，重新开辟内存地址，对象改变，互不影响。

        """
···深浅拷贝都是对源对象的复制，占用不同的内存空间
···如果源对象只有一级目录的话，源做任何改动，不影响深浅拷贝对象
···如果源对象不止一级目录的话，源做任何改动，都要影响浅拷贝，但不影响深拷贝
···序列对象的切片其实是浅拷贝，即只拷贝顶级的对象
        """
'''

import copy

# print("-----------------浅拷贝-----------------------------")
# # 浅拷贝
# name = ["hujianli", "man", 20, ["刘亦菲", "高圆圆", "关晓彤"]]
# # name1 = name.copy()           ## 浅拷贝方式1，注意：只有可变对象才有.copy()方法。
# # name1 = copy.copy(name)       ## 浅拷贝方式2，内存开辟新的空间,
# name1 = name[::]  ## ## 浅拷贝方式2
#
# print(name, "-------->", id(name))
# print(name1, "----------->", id(name1))
# # 修改可变对象,拷贝副本和原始数据共用可变对象。
# name[3].append("鸭蛋")
# print(name)
# print(name1)
# print()
# # 修改不可变对象,原始数据的指向更改，拷贝数据指向不变。原始数据改变，拷贝副本不变
# name[0] = "huxiaojian"
# print(name)
# print(name1)
# print()
#
# name[2] = 18
# print(name, id(name))
# print(name1, id(name1))

print("-----------------深拷贝-----------------------------")

'''
深拷贝
'''
names = ["hujianli", "man", 20, ["刘亦菲", "高圆圆", "关晓彤"]]
print("深拷贝前的内存地址：", id(names), "\n")  # 深拷贝前的内存地址： 2870042609032
for name in names:
    print(name, "------->", id(name))

'''
hujianli -------> 2869986533744
man -------> 2869992892992
20 -------> 1762591824
['刘亦菲', '高圆圆', '关晓彤'] -------> 2870042609096
'''

name2 = copy.deepcopy(names)  # 深拷贝后的内存地址： 2869992973832
print("深拷贝后的内存地址：", id(name2), '\n')  # 重新开辟内存空间
for name in name2:
    print(name, "---->", id(name))

'''
hujianli ----> 2869986533744                                # 不可变对象，指向了内存空间中的引用
man ----> 2869992892992
20 ----> 1762591824
['刘亦菲', '高圆圆', '关晓彤'] ----> 2869986533640           # 对于可变对象新开辟了空间
'''


# 因为列表中的可变对象是新开辟的空间，所以进行修改不影响深拷贝的内容
names[3].pop()
names.reverse()
print(names)  # [['刘亦菲', '高圆圆'], 20, 'man', 'hujianli']
print(name2)  # ['hujianli', 'man', 20, ['刘亦菲', '高圆圆', '关晓彤']]
